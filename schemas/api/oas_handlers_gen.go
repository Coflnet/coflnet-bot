// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"

	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

// handleAPIAuctionAuctionUuidGetRequest handles GET /api/auction/{auctionUuid} operation.
//
// Retrieve details of a specific auction.
//
// GET /api/auction/{auctionUuid}
func (s *Server) handleAPIAuctionAuctionUuidGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionAuctionUuidGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionAuctionUuidGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionAuctionUuidGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ColorSaveAuction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionAuctionUuidGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "auctionUuid",
					In:   "path",
				}: params.AuctionUuid,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionAuctionUuidGetParams
			Response = *ColorSaveAuction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionAuctionUuidGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionAuctionUuidGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionAuctionUuidGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionAuctionUuidGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionAuctionUuidUIDGetRequest handles GET /api/auction/{auctionUuid}/uid operation.
//
// Retrieve the uid of an auction (mainly a helper to get the lookup id for another service).
//
// GET /api/auction/{auctionUuid}/uid
func (s *Server) handleAPIAuctionAuctionUuidUIDGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionAuctionUuidUIDGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionAuctionUuidUIDGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionAuctionUuidUIDGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response APIAuctionAuctionUuidUIDGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionAuctionUuidUIDGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "auctionUuid",
					In:   "path",
				}: params.AuctionUuid,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionAuctionUuidUIDGetParams
			Response = APIAuctionAuctionUuidUIDGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionAuctionUuidUIDGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionAuctionUuidUIDGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionAuctionUuidUIDGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionAuctionUuidUIDGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsActiveUUIDPostRequest handles POST /api/auctions/active/uuid operation.
//
// Checks an array of item uuids if they are active on the ah.
//
// POST /api/auctions/active/uuid
func (s *Server) handleAPIAuctionsActiveUUIDPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsActiveUUIDPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsActiveUUIDPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIAuctionsActiveUUIDPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []string
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsActiveUUIDPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = []string
			Params   = struct{}
			Response = []string
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsActiveUUIDPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsActiveUUIDPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsActiveUUIDPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsBatchGetRequest handles GET /api/auctions/batch operation.
//
// Batch raw item value export, requires token.
//
// GET /api/auctions/batch
func (s *Server) handleAPIAuctionsBatchGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsBatchGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsBatchGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionsBatchGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *APIAuctionsBatchGetOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsBatchGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "token",
					In:   "query",
				}: params.Token,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionsBatchGetParams
			Response = *APIAuctionsBatchGetOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionsBatchGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIAuctionsBatchGet(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.APIAuctionsBatchGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsBatchGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsSupplyLowGetRequest handles GET /api/auctions/supply/low operation.
//
// Get items that are in low supply.
//
// GET /api/auctions/supply/low
func (s *Server) handleAPIAuctionsSupplyLowGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsSupplyLowGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []SupplyElement
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsSupplyLowGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []SupplyElement
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsSupplyLowGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsSupplyLowGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsSupplyLowGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsTagItemTagActiveBinGetRequest handles GET /api/auctions/tag/{itemTag}/active/bin operation.
//
// Get the 10 (or how many are available) lowest bins.
//
// GET /api/auctions/tag/{itemTag}/active/bin
func (s *Server) handleAPIAuctionsTagItemTagActiveBinGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsTagItemTagActiveBinGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsTagItemTagActiveBinGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionsTagItemTagActiveBinGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []SaveAuction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsTagItemTagActiveBinGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionsTagItemTagActiveBinGetParams
			Response = []SaveAuction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionsTagItemTagActiveBinGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsTagItemTagActiveBinGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsTagItemTagActiveBinGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsTagItemTagActiveBinGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsTagItemTagActiveOverviewGetRequest handles GET /api/auctions/tag/{itemTag}/active/overview operation.
//
// Gets a preview of active auctions useful in overviews, available orderBy options
// HIGHEST_PRICE, LOWEST_PRICE (default), ENDING_SOON.
//
// GET /api/auctions/tag/{itemTag}/active/overview
func (s *Server) handleAPIAuctionsTagItemTagActiveOverviewGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsTagItemTagActiveOverviewGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsTagItemTagActiveOverviewGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionsTagItemTagActiveOverviewGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuctionPreview
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsTagItemTagActiveOverviewGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionsTagItemTagActiveOverviewGetParams
			Response = []AuctionPreview
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionsTagItemTagActiveOverviewGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsTagItemTagActiveOverviewGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsTagItemTagActiveOverviewGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsTagItemTagActiveOverviewGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsTagItemTagRecentOverviewGetRequest handles GET /api/auctions/tag/{itemTag}/recent/overview operation.
//
// Gets a preview of recent auctions useful in overviews.
//
// GET /api/auctions/tag/{itemTag}/recent/overview
func (s *Server) handleAPIAuctionsTagItemTagRecentOverviewGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsTagItemTagRecentOverviewGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsTagItemTagRecentOverviewGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionsTagItemTagRecentOverviewGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuctionPreview
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsTagItemTagRecentOverviewGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionsTagItemTagRecentOverviewGetParams
			Response = []AuctionPreview
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionsTagItemTagRecentOverviewGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsTagItemTagRecentOverviewGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsTagItemTagRecentOverviewGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsTagItemTagRecentOverviewGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsTagItemTagSoldGetRequest handles GET /api/auctions/tag/{itemTag}/sold operation.
//
// Get a batch of 1000 auctions that sold in the last week for any kind of processing.
// Please credit us with providing data for whatever you are doing.
// You can also manually request a review to get older data on the discord.
//
// GET /api/auctions/tag/{itemTag}/sold
func (s *Server) handleAPIAuctionsTagItemTagSoldGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsTagItemTagSoldGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsTagItemTagSoldGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionsTagItemTagSoldGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []SaveAuction
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsTagItemTagSoldGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionsTagItemTagSoldGetParams
			Response = []SaveAuction
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionsTagItemTagSoldGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsTagItemTagSoldGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsTagItemTagSoldGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsTagItemTagSoldGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsUIDUIDSoldGetRequest handles GET /api/auctions/uid/{uid}/sold operation.
//
// Gets all recorded past sells of an item with a specific uuid
// meant for dupe detection.
//
// GET /api/auctions/uid/{uid}/sold
func (s *Server) handleAPIAuctionsUIDUIDSoldGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsUIDUIDSoldGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsUIDUIDSoldGet",
			ID:   "",
		}
	)
	params, err := decodeAPIAuctionsUIDUIDSoldGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []ItemSell
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsUIDUIDSoldGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "uid",
					In:   "path",
				}: params.UID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIAuctionsUIDUIDSoldGetParams
			Response = []ItemSell
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIAuctionsUIDUIDSoldGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIAuctionsUIDUIDSoldGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIAuctionsUIDUIDSoldGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsUIDUIDSoldGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIAuctionsUidsSoldPostRequest handles POST /api/auctions/uids/sold operation.
//
// Gets all recorded past sells of a batch of items by uuid
// meant for dupe detection of whole inventories.
//
// POST /api/auctions/uids/sold
func (s *Server) handleAPIAuctionsUidsSoldPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIAuctionsUidsSoldPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIAuctionsUidsSoldPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIAuctionsUidsSoldPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIAuctionsUidsSoldPostOKApplicationJSON
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIAuctionsUidsSoldPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *InventoryBatchLookup
			Params   = struct{}
			Response = *APIAuctionsUidsSoldPostOKApplicationJSON
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIAuctionsUidsSoldPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIAuctionsUidsSoldPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIAuctionsUidsSoldPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIBazaarItemHistoryItemTagStatusGetRequest handles GET /api/bazaar/item/history/{itemTag}/status operation.
//
// Returns bazaar history.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /api/bazaar/item/history/{itemTag}/status
func (s *Server) handleAPIBazaarItemHistoryItemTagStatusGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIBazaarItemHistoryItemTagStatusGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIBazaarItemHistoryItemTagStatusGet",
			ID:   "",
		}
	)
	params, err := decodeAPIBazaarItemHistoryItemTagStatusGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response APIBazaarItemHistoryItemTagStatusGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIBazaarItemHistoryItemTagStatusGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIBazaarItemHistoryItemTagStatusGetParams
			Response = APIBazaarItemHistoryItemTagStatusGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIBazaarItemHistoryItemTagStatusGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIBazaarItemHistoryItemTagStatusGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIBazaarItemHistoryItemTagStatusGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIBazaarItemHistoryItemTagStatusGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIBazaarItemTagHistoryDayGetRequest handles GET /api/bazaar/{itemTag}/history/day operation.
//
// Gets the history data for display in a graph for one day ( in intervalls of 5 minutes).
//
// GET /api/bazaar/{itemTag}/history/day
func (s *Server) handleAPIBazaarItemTagHistoryDayGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIBazaarItemTagHistoryDayGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIBazaarItemTagHistoryDayGet",
			ID:   "",
		}
	)
	params, err := decodeAPIBazaarItemTagHistoryDayGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []GraphResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIBazaarItemTagHistoryDayGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIBazaarItemTagHistoryDayGetParams
			Response = []GraphResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIBazaarItemTagHistoryDayGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIBazaarItemTagHistoryDayGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIBazaarItemTagHistoryDayGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIBazaarItemTagHistoryDayGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIBazaarItemTagHistoryGetRequest handles GET /api/bazaar/{itemTag}/history operation.
//
// Gets the history data for display in a graph.
//
// GET /api/bazaar/{itemTag}/history
func (s *Server) handleAPIBazaarItemTagHistoryGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIBazaarItemTagHistoryGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIBazaarItemTagHistoryGet",
			ID:   "",
		}
	)
	params, err := decodeAPIBazaarItemTagHistoryGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []GraphResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIBazaarItemTagHistoryGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIBazaarItemTagHistoryGetParams
			Response = []GraphResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIBazaarItemTagHistoryGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIBazaarItemTagHistoryGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIBazaarItemTagHistoryGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIBazaarItemTagHistoryGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIBazaarItemTagHistoryHourGetRequest handles GET /api/bazaar/{itemTag}/history/hour operation.
//
// Gets the history data for display in a graph for one hour ( in intervalls of 10 seconds).
//
// GET /api/bazaar/{itemTag}/history/hour
func (s *Server) handleAPIBazaarItemTagHistoryHourGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIBazaarItemTagHistoryHourGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIBazaarItemTagHistoryHourGet",
			ID:   "",
		}
	)
	params, err := decodeAPIBazaarItemTagHistoryHourGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []GraphResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIBazaarItemTagHistoryHourGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIBazaarItemTagHistoryHourGetParams
			Response = []GraphResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIBazaarItemTagHistoryHourGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIBazaarItemTagHistoryHourGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIBazaarItemTagHistoryHourGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIBazaarItemTagHistoryHourGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIBazaarItemTagHistoryWeekGetRequest handles GET /api/bazaar/{itemTag}/history/week operation.
//
// Gets the history data for display in a graph for one week ( in intervalls of 2 hours).
//
// GET /api/bazaar/{itemTag}/history/week
func (s *Server) handleAPIBazaarItemTagHistoryWeekGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIBazaarItemTagHistoryWeekGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIBazaarItemTagHistoryWeekGet",
			ID:   "",
		}
	)
	params, err := decodeAPIBazaarItemTagHistoryWeekGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []GraphResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIBazaarItemTagHistoryWeekGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIBazaarItemTagHistoryWeekGetParams
			Response = []GraphResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIBazaarItemTagHistoryWeekGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIBazaarItemTagHistoryWeekGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIBazaarItemTagHistoryWeekGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIBazaarItemTagHistoryWeekGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIBazaarItemTagSnapshotGetRequest handles GET /api/bazaar/{itemTag}/snapshot operation.
//
// Gets a snapshot of a specific item at a specific time.
//
// GET /api/bazaar/{itemTag}/snapshot
func (s *Server) handleAPIBazaarItemTagSnapshotGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIBazaarItemTagSnapshotGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIBazaarItemTagSnapshotGet",
			ID:   "",
		}
	)
	params, err := decodeAPIBazaarItemTagSnapshotGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *StorageQuickStatus
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIBazaarItemTagSnapshotGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "timestamp",
					In:   "query",
				}: params.Timestamp,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIBazaarItemTagSnapshotGetParams
			Response = *StorageQuickStatus
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIBazaarItemTagSnapshotGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIBazaarItemTagSnapshotGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIBazaarItemTagSnapshotGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIBazaarItemTagSnapshotGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPICraftAPICraftGetRequest handles GET /api/craft/api/craft operation.
//
// Returns the crafting recipe for some item.
//
// GET /api/craft/api/craft
func (s *Server) handleAPICraftAPICraftGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APICraftAPICraftGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *APICraftAPICraftGetOKApplicationJSON
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APICraftAPICraftGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *APICraftAPICraftGetOKApplicationJSON
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APICraftAPICraftGet(ctx)
				return response, err
			},
		)
	} else {
		err = s.h.APICraftAPICraftGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPICraftAPICraftGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPICraftProfitGetRequest handles GET /api/craft/profit operation.
//
// Craft flips.
//
// GET /api/craft/profit
func (s *Server) handleAPICraftProfitGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APICraftProfitGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APICraftProfitGet",
			ID:   "",
		}
	)
	params, err := decodeAPICraftProfitGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []ProfitableCraft
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APICraftProfitGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "player",
					In:   "query",
				}: params.Player,
				{
					Name: "profile",
					In:   "query",
				}: params.Profile,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APICraftProfitGetParams
			Response = []ProfitableCraft
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPICraftProfitGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APICraftProfitGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APICraftProfitGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPICraftProfitGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPICraftRecipeItemTagGetRequest handles GET /api/craft/recipe/{itemTag} operation.
//
// Returns the crafting recipe for some item.
//
// GET /api/craft/recipe/{itemTag}
func (s *Server) handleAPICraftRecipeItemTagGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APICraftRecipeItemTagGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APICraftRecipeItemTagGet",
			ID:   "",
		}
	)
	params, err := decodeAPICraftRecipeItemTagGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *APICraftRecipeItemTagGetOKApplicationJSON
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APICraftRecipeItemTagGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APICraftRecipeItemTagGetParams
			Response = *APICraftRecipeItemTagGetOKApplicationJSON
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPICraftRecipeItemTagGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APICraftRecipeItemTagGet(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.APICraftRecipeItemTagGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPICraftRecipeItemTagGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIDataPlayerNamePostRequest handles POST /api/data/playerName operation.
//
// Accepts player name based auction hints.
//
// POST /api/data/playerName
func (s *Server) handleAPIDataPlayerNamePostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIDataPlayerNamePost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIDataPlayerNamePost",
			ID:   "",
		}
	)
	params, err := decodeAPIDataPlayerNamePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *Int32Int64ValueTuple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIDataPlayerNamePost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "name",
					In:   "query",
				}: params.Name,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIDataPlayerNamePostParams
			Response = *Int32Int64ValueTuple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIDataPlayerNamePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIDataPlayerNamePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIDataPlayerNamePost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIDataPlayerNamePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIDataPlayerNamesPostRequest handles POST /api/data/playerNames operation.
//
// Accepts player name based auction hints.
//
// POST /api/data/playerNames
func (s *Server) handleAPIDataPlayerNamesPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIDataPlayerNamesPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIDataPlayerNamesPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIDataPlayerNamesPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []Int32Int64ValueTuple
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIDataPlayerNamesPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = []string
			Params   = struct{}
			Response = []Int32Int64ValueTuple
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIDataPlayerNamesPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIDataPlayerNamesPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIDataPlayerNamesPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIDataProxyPostRequest handles POST /api/data/proxy operation.
//
// Endpoint to upload proxied data.
//
// POST /api/data/proxy
func (s *Server) handleAPIDataProxyPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIDataProxyPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response APIDataProxyPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIDataProxyPost",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = APIDataProxyPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIDataProxyPost(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIDataProxyPost(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIDataProxyPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFilterOptionsGetRequest handles GET /api/filter/options operation.
//
// Returns all available filters with all available options.
//
// GET /api/filter/options
func (s *Server) handleAPIFilterOptionsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFilterOptionsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFilterOptionsGet",
			ID:   "",
		}
	)
	params, err := decodeAPIFilterOptionsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []FilterOptions
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFilterOptionsGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "query",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIFilterOptionsGetParams
			Response = []FilterOptions
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIFilterOptionsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFilterOptionsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFilterOptionsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFilterOptionsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFilterPostRequest handles POST /api/Filter operation.
//
// POST /api/Filter
func (s *Server) handleAPIFilterPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFilterPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFilterPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIFilterPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response bool
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFilterPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *FilterQuery
			Params   = struct{}
			Response = bool
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFilterPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFilterPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFilterPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipSettingsOptionsGetRequest handles GET /api/flip/settings/options operation.
//
// Shows you the available settings options for the socket comand subFlip,
// Doesn't currently actually do anything.
//
// GET /api/flip/settings/options
func (s *Server) handleAPIFlipSettingsOptionsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipSettingsOptionsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *FlipSettings
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipSettingsOptionsGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *FlipSettings
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFlipSettingsOptionsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFlipSettingsOptionsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipSettingsOptionsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipStatsFinderFinderNameGetRequest handles GET /api/flip/stats/finder/{finderName} operation.
//
// Get flips stats for one type of flip finder.
//
// GET /api/flip/stats/finder/{finderName}
func (s *Server) handleAPIFlipStatsFinderFinderNameGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipStatsFinderFinderNameGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFlipStatsFinderFinderNameGet",
			ID:   "",
		}
	)
	params, err := decodeAPIFlipStatsFinderFinderNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []FlipDetails
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipStatsFinderFinderNameGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "finderName",
					In:   "path",
				}: params.FinderName,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIFlipStatsFinderFinderNameGetParams
			Response = []FlipDetails
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIFlipStatsFinderFinderNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFlipStatsFinderFinderNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFlipStatsFinderFinderNameGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipStatsFinderFinderNameGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipStatsPlayerPlayerUuidGetRequest handles GET /api/flip/stats/player/{playerUuid} operation.
//
// Get flips stats for player.
//
// GET /api/flip/stats/player/{playerUuid}
func (s *Server) handleAPIFlipStatsPlayerPlayerUuidGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipStatsPlayerPlayerUuidGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFlipStatsPlayerPlayerUuidGet",
			ID:   "",
		}
	)
	params, err := decodeAPIFlipStatsPlayerPlayerUuidGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *FlipSumary
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipStatsPlayerPlayerUuidGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerUuid",
					In:   "path",
				}: params.PlayerUuid,
				{
					Name: "days",
					In:   "query",
				}: params.Days,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIFlipStatsPlayerPlayerUuidGetParams
			Response = *FlipSumary
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIFlipStatsPlayerPlayerUuidGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFlipStatsPlayerPlayerUuidGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFlipStatsPlayerPlayerUuidGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipStatsPlayerPlayerUuidGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipStatsPlayerPlayerUuidHourGetRequest handles GET /api/flip/stats/player/{playerUuid}/hour operation.
//
// Get flips stats for player for the last hour (faster).
//
// GET /api/flip/stats/player/{playerUuid}/hour
func (s *Server) handleAPIFlipStatsPlayerPlayerUuidHourGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipStatsPlayerPlayerUuidHourGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFlipStatsPlayerPlayerUuidHourGet",
			ID:   "",
		}
	)
	params, err := decodeAPIFlipStatsPlayerPlayerUuidHourGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *FlipSumary
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipStatsPlayerPlayerUuidHourGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerUuid",
					In:   "path",
				}: params.PlayerUuid,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIFlipStatsPlayerPlayerUuidHourGetParams
			Response = *FlipSumary
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIFlipStatsPlayerPlayerUuidHourGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFlipStatsPlayerPlayerUuidHourGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFlipStatsPlayerPlayerUuidHourGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipStatsPlayerPlayerUuidHourGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipTrackFoundAuctionIdPostRequest handles POST /api/flip/track/found/{auctionId} operation.
//
// Callback for external flip finders to be included in tracking.
//
// POST /api/flip/track/found/{auctionId}
func (s *Server) handleAPIFlipTrackFoundAuctionIdPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipTrackFoundAuctionIdPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFlipTrackFoundAuctionIdPost",
			ID:   "",
		}
	)
	params, err := decodeAPIFlipTrackFoundAuctionIdPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *APIFlipTrackFoundAuctionIdPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipTrackFoundAuctionIdPost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "auctionId",
					In:   "path",
				}: params.AuctionId,
				{
					Name: "finder",
					In:   "query",
				}: params.Finder,
				{
					Name: "price",
					In:   "query",
				}: params.Price,
				{
					Name: "timeStamp",
					In:   "query",
				}: params.TimeStamp,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIFlipTrackFoundAuctionIdPostParams
			Response = *APIFlipTrackFoundAuctionIdPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIFlipTrackFoundAuctionIdPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIFlipTrackFoundAuctionIdPost(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.APIFlipTrackFoundAuctionIdPost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipTrackFoundAuctionIdPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipTrackPurchaseAuctionIdPostRequest handles POST /api/flip/track/purchase/{auctionId} operation.
//
// Callback for external flip finders to be included in tracking.
//
// POST /api/flip/track/purchase/{auctionId}
func (s *Server) handleAPIFlipTrackPurchaseAuctionIdPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipTrackPurchaseAuctionIdPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIFlipTrackPurchaseAuctionIdPost",
			ID:   "",
		}
	)
	params, err := decodeAPIFlipTrackPurchaseAuctionIdPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *APIFlipTrackPurchaseAuctionIdPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipTrackPurchaseAuctionIdPost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "auctionId",
					In:   "path",
				}: params.AuctionId,
				{
					Name: "finder",
					In:   "query",
				}: params.Finder,
				{
					Name: "playerId",
					In:   "query",
				}: params.PlayerId,
				{
					Name: "price",
					In:   "query",
				}: params.Price,
				{
					Name: "timeStamp",
					In:   "query",
				}: params.TimeStamp,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIFlipTrackPurchaseAuctionIdPostParams
			Response = *APIFlipTrackPurchaseAuctionIdPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIFlipTrackPurchaseAuctionIdPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIFlipTrackPurchaseAuctionIdPost(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.APIFlipTrackPurchaseAuctionIdPost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipTrackPurchaseAuctionIdPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIFlipUpdateWhenGetRequest handles GET /api/flip/update/when operation.
//
// The last time an update was loaded (cached for 30min)
// You should only look at the second part.
//
// GET /api/flip/update/when
func (s *Server) handleAPIFlipUpdateWhenGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIFlipUpdateWhenGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response time.Time
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIFlipUpdateWhenGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = time.Time
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIFlipUpdateWhenGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIFlipUpdateWhenGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIFlipUpdateWhenGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemItemTagDetailsGetRequest handles GET /api/item/{itemTag}/details operation.
//
// Returns details about a specific item
// This gets updated once every hour.
//
// GET /api/item/{itemTag}/details
func (s *Server) handleAPIItemItemTagDetailsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemItemTagDetailsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemItemTagDetailsGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemItemTagDetailsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *SkyblockItem
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemItemTagDetailsGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemItemTagDetailsGetParams
			Response = *SkyblockItem
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemItemTagDetailsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemItemTagDetailsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemItemTagDetailsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemItemTagDetailsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemItemTagSimilarGetRequest handles GET /api/item/{itemTag}/similar operation.
//
// Other items related to some tag.
//
// GET /api/item/{itemTag}/similar
func (s *Server) handleAPIItemItemTagSimilarGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemItemTagSimilarGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemItemTagSimilarGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemItemTagSimilarGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []ItemPreview
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemItemTagSimilarGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemItemTagSimilarGetParams
			Response = []ItemPreview
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemItemTagSimilarGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemItemTagSimilarGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemItemTagSimilarGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemItemTagSimilarGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagBinGetRequest handles GET /api/item/price/{itemTag}/bin operation.
//
// Gets the lowest bin by item type.
//
// GET /api/item/price/{itemTag}/bin
func (s *Server) handleAPIItemPriceItemTagBinGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagBinGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagBinGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagBinGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *BinResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagBinGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagBinGetParams
			Response = *BinResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagBinGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagBinGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagBinGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagBinGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagCurrentGetRequest handles GET /api/item/price/{itemTag}/current operation.
//
// Gets the current (latest known) price for an item and available quantity, supports items from
// bazaar and ah.
//
// GET /api/item/price/{itemTag}/current
func (s *Server) handleAPIItemPriceItemTagCurrentGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagCurrentGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagCurrentGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagCurrentGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *CurrentPrice
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagCurrentGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagCurrentGetParams
			Response = *CurrentPrice
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagCurrentGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagCurrentGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagCurrentGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagCurrentGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagGetRequest handles GET /api/item/price/{itemTag} operation.
//
// Aggregated sumary of item prices for the 3 last days.
//
// GET /api/item/price/{itemTag}
func (s *Server) handleAPIItemPriceItemTagGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *PriceSumary
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagGetParams
			Response = *PriceSumary
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagHistoryDayGetRequest handles GET /api/item/price/{itemTag}/history/day operation.
//
// Gets the price history for an item for the last 24 hours.
//
// GET /api/item/price/{itemTag}/history/day
func (s *Server) handleAPIItemPriceItemTagHistoryDayGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagHistoryDayGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagHistoryDayGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagHistoryDayGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AveragePrice
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagHistoryDayGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagHistoryDayGetParams
			Response = []AveragePrice
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagHistoryDayGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagHistoryDayGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagHistoryDayGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagHistoryDayGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagHistoryFullGetRequest handles GET /api/item/price/{itemTag}/history/full operation.
//
// Gets the price history for an item for all time.
//
// GET /api/item/price/{itemTag}/history/full
func (s *Server) handleAPIItemPriceItemTagHistoryFullGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagHistoryFullGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagHistoryFullGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagHistoryFullGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AveragePrice
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagHistoryFullGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagHistoryFullGetParams
			Response = []AveragePrice
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagHistoryFullGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagHistoryFullGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagHistoryFullGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagHistoryFullGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagHistoryMonthGetRequest handles GET /api/item/price/{itemTag}/history/month operation.
//
// Gets the price history for an item for one month.
//
// GET /api/item/price/{itemTag}/history/month
func (s *Server) handleAPIItemPriceItemTagHistoryMonthGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagHistoryMonthGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagHistoryMonthGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagHistoryMonthGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AveragePrice
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagHistoryMonthGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagHistoryMonthGetParams
			Response = []AveragePrice
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagHistoryMonthGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagHistoryMonthGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagHistoryMonthGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagHistoryMonthGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemPriceItemTagHistoryWeekGetRequest handles GET /api/item/price/{itemTag}/history/week operation.
//
// Gets the price history for an item for the last 7 days.
//
// GET /api/item/price/{itemTag}/history/week
func (s *Server) handleAPIItemPriceItemTagHistoryWeekGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemPriceItemTagHistoryWeekGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemPriceItemTagHistoryWeekGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemPriceItemTagHistoryWeekGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AveragePrice
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemPriceItemTagHistoryWeekGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "itemTag",
					In:   "path",
				}: params.ItemTag,
				{
					Name: "query",
					In:   "query",
				}: params.Query,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemPriceItemTagHistoryWeekGetParams
			Response = []AveragePrice
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemPriceItemTagHistoryWeekGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemPriceItemTagHistoryWeekGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemPriceItemTagHistoryWeekGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemPriceItemTagHistoryWeekGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemSearchSearchValGetRequest handles GET /api/item/search/{searchVal} operation.
//
// Searches through all items, includes the rarity of items.
//
// GET /api/item/search/{searchVal}
func (s *Server) handleAPIItemSearchSearchValGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemSearchSearchValGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemSearchSearchValGet",
			ID:   "",
		}
	)
	params, err := decodeAPIItemSearchSearchValGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []SearchResultItem
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemSearchSearchValGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "searchVal",
					In:   "path",
				}: params.SearchVal,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIItemSearchSearchValGetParams
			Response = []SearchResultItem
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIItemSearchSearchValGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemSearchSearchValGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemSearchSearchValGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemSearchSearchValGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemsBazaarTagsGetRequest handles GET /api/items/bazaar/tags operation.
//
// A list of item tags (hypixel ids) that are tradeable on bazaar
// This gets updated once every hour.
//
// GET /api/items/bazaar/tags
func (s *Server) handleAPIItemsBazaarTagsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemsBazaarTagsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []string
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemsBazaarTagsGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []string
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemsBazaarTagsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemsBazaarTagsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemsBazaarTagsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemsGetRequest handles GET /api/items operation.
//
// Get all item tags, names and wherever they are on ah or bazaar.
//
// GET /api/items
func (s *Server) handleAPIItemsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []ItemMetadataElement
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemsGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []ItemMetadataElement
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIItemsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIItemsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIItemsNamesPostRequest handles POST /api/items/names operation.
//
// Batch lookup names for item tags.
//
// POST /api/items/names
func (s *Server) handleAPIItemsNamesPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIItemsNamesPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIItemsNamesPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIItemsNamesPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIItemsNamesPostOKApplicationJSON
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIItemsNamesPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = []string
			Params   = struct{}
			Response = *APIItemsNamesPostOKApplicationJSON
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIItemsNamesPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIItemsNamesPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIItemsNamesPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIKatDataGetRequest handles GET /api/kat/data operation.
//
// Raw data of upgrade cost.
//
// GET /api/kat/data
func (s *Server) handleAPIKatDataGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIKatDataGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []KatUpgradeCost
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIKatDataGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []KatUpgradeCost
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIKatDataGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIKatDataGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIKatDataGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIKatProfitGetRequest handles GET /api/kat/profit operation.
//
// Kat flips.
//
// GET /api/kat/profit
func (s *Server) handleAPIKatProfitGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIKatProfitGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []KatFlip
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIKatProfitGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []KatFlip
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIKatProfitGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIKatProfitGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIKatProfitGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIMayorGetRequest handles GET /api/mayor operation.
//
// Gets election data between two Timestamps.
//
// GET /api/mayor
func (s *Server) handleAPIMayorGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIMayorGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIMayorGet",
			ID:   "",
		}
	)
	params, err := decodeAPIMayorGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []ModelElectionPeriod
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIMayorGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "from",
					In:   "query",
				}: params.From,
				{
					Name: "to",
					In:   "query",
				}: params.To,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIMayorGetParams
			Response = []ModelElectionPeriod
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIMayorGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIMayorGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIMayorGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIMayorGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIMayorYearGetRequest handles GET /api/mayor/{year} operation.
//
// Return Election results for a specific year.
//
// GET /api/mayor/{year}
func (s *Server) handleAPIMayorYearGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIMayorYearGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIMayorYearGet",
			ID:   "",
		}
	)
	params, err := decodeAPIMayorYearGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *ModelElectionPeriod
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIMayorYearGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "year",
					In:   "path",
				}: params.Year,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIMayorYearGetParams
			Response = *ModelElectionPeriod
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIMayorYearGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIMayorYearGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIMayorYearGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIMayorYearGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIModCommandsGetRequest handles GET /api/mod/commands operation.
//
// Returns a list of available server-side commands.
//
// GET /api/mod/commands
func (s *Server) handleAPIModCommandsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIModCommandsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []CommandListEntry
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIModCommandsGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []CommandListEntry
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIModCommandsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIModCommandsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIModCommandsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIModDescriptionModificationsPostRequest handles POST /api/mod/description/modifications operation.
//
// Returns a collection of modifications for each item passed.
//
// POST /api/mod/description/modifications
func (s *Server) handleAPIModDescriptionModificationsPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIModDescriptionModificationsPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIModDescriptionModificationsPost",
			ID:   "",
		}
	)
	params, err := decodeAPIModDescriptionModificationsPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAPIModDescriptionModificationsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response APIModDescriptionModificationsPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIModDescriptionModificationsPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "conId",
					In:   "header",
				}: params.ConId,
				{
					Name: "uuid",
					In:   "header",
				}: params.UUID,
			},
			Raw: r,
		}

		type (
			Request  = *InventoryData
			Params   = APIModDescriptionModificationsPostParams
			Response = APIModDescriptionModificationsPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIModDescriptionModificationsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIModDescriptionModificationsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIModDescriptionModificationsPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIModDescriptionModificationsPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIModDescriptionPostRequest handles POST /api/mod/description operation.
//
// Returns new descriptions for an array of items.
//
// POST /api/mod/description
func (s *Server) handleAPIModDescriptionPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIModDescriptionPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIModDescriptionPost",
			ID:   "",
		}
	)
	params, err := decodeAPIModDescriptionPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAPIModDescriptionPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response APIModDescriptionPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIModDescriptionPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "conId",
					In:   "header",
				}: params.ConId,
				{
					Name: "uuid",
					In:   "header",
				}: params.UUID,
			},
			Raw: r,
		}

		type (
			Request  = *InventoryData
			Params   = APIModDescriptionPostParams
			Response = APIModDescriptionPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIModDescriptionPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIModDescriptionPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIModDescriptionPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIModDescriptionPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIModItemUUIDGetRequest handles GET /api/mod/item/{uuid} operation.
//
// Returns extra information for an item.
//
// GET /api/mod/item/{uuid}
func (s *Server) handleAPIModItemUUIDGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIModItemUUIDGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIModItemUUIDGet",
			ID:   "",
		}
	)
	params, err := decodeAPIModItemUUIDGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response APIModItemUUIDGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIModItemUUIDGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "uuid",
					In:   "path",
				}: params.UUID,
				{
					Name: "count",
					In:   "query",
				}: params.Count,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIModItemUUIDGetParams
			Response = APIModItemUUIDGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIModItemUUIDGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIModItemUUIDGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIModItemUUIDGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIModItemUUIDGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPlayerPlayerUuidAuctionsGetRequest handles GET /api/player/{playerUuid}/auctions operation.
//
// The last 10 auctions a player created.
//
// GET /api/player/{playerUuid}/auctions
func (s *Server) handleAPIPlayerPlayerUuidAuctionsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPlayerPlayerUuidAuctionsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPlayerPlayerUuidAuctionsGet",
			ID:   "",
		}
	)
	params, err := decodeAPIPlayerPlayerUuidAuctionsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []AuctionResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPlayerPlayerUuidAuctionsGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerUuid",
					In:   "path",
				}: params.PlayerUuid,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "filters",
					In:   "query",
				}: params.Filters,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIPlayerPlayerUuidAuctionsGetParams
			Response = []AuctionResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIPlayerPlayerUuidAuctionsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIPlayerPlayerUuidAuctionsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIPlayerPlayerUuidAuctionsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPlayerPlayerUuidAuctionsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPlayerPlayerUuidBidsGetRequest handles GET /api/player/{playerUuid}/bids operation.
//
// The last 10 bids (with auction) a player did.
//
// GET /api/player/{playerUuid}/bids
func (s *Server) handleAPIPlayerPlayerUuidBidsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPlayerPlayerUuidBidsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPlayerPlayerUuidBidsGet",
			ID:   "",
		}
	)
	params, err := decodeAPIPlayerPlayerUuidBidsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []BidResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPlayerPlayerUuidBidsGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerUuid",
					In:   "path",
				}: params.PlayerUuid,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "filters",
					In:   "query",
				}: params.Filters,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIPlayerPlayerUuidBidsGetParams
			Response = []BidResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIPlayerPlayerUuidBidsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIPlayerPlayerUuidBidsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIPlayerPlayerUuidBidsGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPlayerPlayerUuidBidsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPlayerPlayerUuidNameGetRequest handles GET /api/player/{playerUuid}/name operation.
//
// The name for a given uuid.
//
// GET /api/player/{playerUuid}/name
func (s *Server) handleAPIPlayerPlayerUuidNameGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPlayerPlayerUuidNameGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPlayerPlayerUuidNameGet",
			ID:   "",
		}
	)
	params, err := decodeAPIPlayerPlayerUuidNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response APIPlayerPlayerUuidNameGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPlayerPlayerUuidNameGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerUuid",
					In:   "path",
				}: params.PlayerUuid,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIPlayerPlayerUuidNameGetParams
			Response = APIPlayerPlayerUuidNameGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIPlayerPlayerUuidNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIPlayerPlayerUuidNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIPlayerPlayerUuidNameGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPlayerPlayerUuidNameGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPlayerPlayerUuidNamePostRequest handles POST /api/player/{playerUuid}/name operation.
//
// The name for a given uuid.
//
// POST /api/player/{playerUuid}/name
func (s *Server) handleAPIPlayerPlayerUuidNamePostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPlayerPlayerUuidNamePost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPlayerPlayerUuidNamePost",
			ID:   "",
		}
	)
	params, err := decodeAPIPlayerPlayerUuidNamePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response APIPlayerPlayerUuidNamePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPlayerPlayerUuidNamePost",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerUuid",
					In:   "path",
				}: params.PlayerUuid,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APIPlayerPlayerUuidNamePostParams
			Response = APIPlayerPlayerUuidNamePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPIPlayerPlayerUuidNamePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIPlayerPlayerUuidNamePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIPlayerPlayerUuidNamePost(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPlayerPlayerUuidNamePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPremiumPricesAdjustedPostRequest handles POST /api/premium/prices/adjusted operation.
//
// Get adjusted prices.
//
// POST /api/premium/prices/adjusted
func (s *Server) handleAPIPremiumPricesAdjustedPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPremiumPricesAdjustedPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPremiumPricesAdjustedPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIPremiumPricesAdjustedPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIPremiumPricesAdjustedPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPremiumPricesAdjustedPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = []string
			Params   = struct{}
			Response = *APIPremiumPricesAdjustedPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIPremiumPricesAdjustedPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIPremiumPricesAdjustedPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPremiumPricesAdjustedPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPremiumUserOwnsPostRequest handles POST /api/premium/user/owns operation.
//
// Get adjusted prices.
//
// POST /api/premium/user/owns
func (s *Server) handleAPIPremiumUserOwnsPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPremiumUserOwnsPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPremiumUserOwnsPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIPremiumUserOwnsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIPremiumUserOwnsPostOKApplicationJSON
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPremiumUserOwnsPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = []string
			Params   = struct{}
			Response = *APIPremiumUserOwnsPostOKApplicationJSON
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIPremiumUserOwnsPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIPremiumUserOwnsPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPremiumUserOwnsPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIPriceNbtPostRequest handles POST /api/price/nbt operation.
//
// Returns price estimations for nbt data (for in game mods)
// NOTE: THIS WILL BE A PAID FEATURE IN THE FUTURE.
//
// POST /api/price/nbt
func (s *Server) handleAPIPriceNbtPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIPriceNbtPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIPriceNbtPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIPriceNbtPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response []PriceEstimate
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIPriceNbtPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *InventoryData
			Params   = struct{}
			Response = []PriceEstimate
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIPriceNbtPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIPriceNbtPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIPriceNbtPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIReferralInfoGetRequest handles GET /api/referral/info operation.
//
// Returns ReferralCode and statistics for the user.
//
// GET /api/referral/info
func (s *Server) handleAPIReferralInfoGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIReferralInfoGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *ReferralInfo
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIReferralInfoGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *ReferralInfo
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIReferralInfoGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIReferralInfoGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIReferralInfoGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIReferralReferredByPostRequest handles POST /api/referral/referred/by operation.
//
// Tells the backend that the user was referred by someone.
//
// POST /api/referral/referred/by
func (s *Server) handleAPIReferralReferredByPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIReferralReferredByPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIReferralReferredByPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIReferralReferredByPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIReferralReferredByPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIReferralReferredByPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *ReferredBy
			Params   = struct{}
			Response = *APIReferralReferredByPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIReferralReferredByPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIReferralReferredByPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIReferralReferredByPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPISearchPlayerPlayerNameGetRequest handles GET /api/search/player/{playerName} operation.
//
// Search player.
//
// GET /api/search/player/{playerName}
func (s *Server) handleAPISearchPlayerPlayerNameGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APISearchPlayerPlayerNameGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APISearchPlayerPlayerNameGet",
			ID:   "",
		}
	)
	params, err := decodeAPISearchPlayerPlayerNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []PlayerResult
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APISearchPlayerPlayerNameGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "playerName",
					In:   "path",
				}: params.PlayerName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APISearchPlayerPlayerNameGetParams
			Response = []PlayerResult
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPISearchPlayerPlayerNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APISearchPlayerPlayerNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APISearchPlayerPlayerNameGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPISearchPlayerPlayerNameGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPISearchSearchValGetRequest handles GET /api/search/{searchVal} operation.
//
// Full search, includes item types, items (by uuid), players, auctions and enchantments.
//
// GET /api/search/{searchVal}
func (s *Server) handleAPISearchSearchValGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APISearchSearchValGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APISearchSearchValGet",
			ID:   "",
		}
	)
	params, err := decodeAPISearchSearchValGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response []SearchResultItem
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APISearchSearchValGet",
			OperationID:   "",
			Body:          nil,
			Params: middleware.Parameters{
				{
					Name: "searchVal",
					In:   "path",
				}: params.SearchVal,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = APISearchSearchValGetParams
			Response = []SearchResultItem
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPISearchSearchValGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APISearchSearchValGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.APISearchSearchValGet(ctx, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPISearchSearchValGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIServicePurchasePostRequest handles POST /api/service/purchase operation.
//
// Purchase a service.
//
// POST /api/service/purchase
func (s *Server) handleAPIServicePurchasePostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIServicePurchasePost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIServicePurchasePost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIServicePurchasePostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIServicePurchasePostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIServicePurchasePost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *PurchaseArgs
			Params   = struct{}
			Response = *APIServicePurchasePostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIServicePurchasePost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIServicePurchasePost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIServicePurchasePostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPITopupOptionsGetRequest handles GET /api/topup/options operation.
//
// Products to top up.
//
// GET /api/topup/options
func (s *Server) handleAPITopupOptionsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APITopupOptionsGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response []TopUpProduct
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APITopupOptionsGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = []TopUpProduct
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APITopupOptionsGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APITopupOptionsGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPITopupOptionsGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPITopupPaypalProductSlugPostRequest handles POST /api/topup/paypal/{productSlug} operation.
//
// Start a new topup session with paypal.
//
// POST /api/topup/paypal/{productSlug}
func (s *Server) handleAPITopupPaypalProductSlugPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APITopupPaypalProductSlugPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APITopupPaypalProductSlugPost",
			ID:   "",
		}
	)
	params, err := decodeAPITopupPaypalProductSlugPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAPITopupPaypalProductSlugPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APITopupPaypalProductSlugPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APITopupPaypalProductSlugPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "productSlug",
					In:   "path",
				}: params.ProductSlug,
			},
			Raw: r,
		}

		type (
			Request  = *TopUpArguments
			Params   = APITopupPaypalProductSlugPostParams
			Response = *APITopupPaypalProductSlugPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPITopupPaypalProductSlugPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APITopupPaypalProductSlugPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.APITopupPaypalProductSlugPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPITopupPaypalProductSlugPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPITopupStripeProductSlugPostRequest handles POST /api/topup/stripe/{productSlug} operation.
//
// Start a new topup session with stripe.
//
// POST /api/topup/stripe/{productSlug}
func (s *Server) handleAPITopupStripeProductSlugPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APITopupStripeProductSlugPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APITopupStripeProductSlugPost",
			ID:   "",
		}
	)
	params, err := decodeAPITopupStripeProductSlugPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeAPITopupStripeProductSlugPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APITopupStripeProductSlugPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APITopupStripeProductSlugPost",
			OperationID:   "",
			Body:          request,
			Params: middleware.Parameters{
				{
					Name: "productSlug",
					In:   "path",
				}: params.ProductSlug,
			},
			Raw: r,
		}

		type (
			Request  = *TopUpArguments
			Params   = APITopupStripeProductSlugPostParams
			Response = *APITopupStripeProductSlugPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackAPITopupStripeProductSlugPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APITopupStripeProductSlugPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		err = s.h.APITopupStripeProductSlugPost(ctx, request, params)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPITopupStripeProductSlugPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIUserPrivacyGetRequest handles GET /api/user/privacy operation.
//
// Get the users privacy settings (requires google token).
//
// GET /api/user/privacy
func (s *Server) handleAPIUserPrivacyGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIUserPrivacyGet",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err error
	)

	var response *PrivacySettings
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIUserPrivacyGet",
			OperationID:   "",
			Body:          nil,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *PrivacySettings
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.APIUserPrivacyGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.APIUserPrivacyGet(ctx)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIUserPrivacyGetResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}

// handleAPIUserPrivacyPostRequest handles POST /api/user/privacy operation.
//
// Update users privacy settings (requires google token).
//
// POST /api/user/privacy
func (s *Server) handleAPIUserPrivacyPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	var otelAttrs []attribute.KeyValue

	// Start a span for this request.
	ctx, span := s.cfg.Tracer.Start(r.Context(), "APIUserPrivacyPost",
		serverSpanKind,
	)
	defer span.End()

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		elapsedDuration := time.Since(startTime)
		// Use floating point division here for higher precision (instead of Millisecond method).
		s.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	s.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	var (
		recordError = func(stage string, err error) {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			s.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "APIUserPrivacyPost",
			ID:   "",
		}
	)
	request, close, err := s.decodeAPIUserPrivacyPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *APIUserPrivacyPostOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:       ctx,
			OperationName: "APIUserPrivacyPost",
			OperationID:   "",
			Body:          request,
			Params:        middleware.Parameters{},
			Raw:           r,
		}

		type (
			Request  = *PrivacySettings
			Params   = struct{}
			Response = *APIUserPrivacyPostOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.APIUserPrivacyPost(ctx, request)
				return response, err
			},
		)
	} else {
		err = s.h.APIUserPrivacyPost(ctx, request)
	}
	if err != nil {
		recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAPIUserPrivacyPostResponse(response, w, span); err != nil {
		recordError("EncodeResponse", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
}
